from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Callable, Dict, Optional


@dataclass
class LeaseInfo:
    lease_id: str
    job_id: str
    client_id: str
    ttl_ms: int
    last_heartbeat_ts: datetime
    lease_expiry_ts: datetime
    heartbeat_interval_ms: int
    state: str

    def expired(self, now: Optional[datetime] = None) -> bool:
        now = now or datetime.utcnow()
        return now >= self.lease_expiry_ts

    def extend(self, ttl_ms: Optional[int] = None, now: Optional[datetime] = None) -> None:
        ttl_ms = ttl_ms if ttl_ms is not None else self.ttl_ms
        now = now or datetime.utcnow()
        self.last_heartbeat_ts = now
        self.lease_expiry_ts = now + timedelta(milliseconds=ttl_ms)


class LeaseManager:
    def __init__(self, now_fn: Optional[Callable[[], datetime]] = None) -> None:
        self._leases_by_id: Dict[str, LeaseInfo] = {}
        self._leases_by_job: Dict[str, LeaseInfo] = {}
        self._now_fn = now_fn or datetime.utcnow

    @property
    def lease(self) -> Optional[LeaseInfo]:
        return next(iter(self._leases_by_id.values()), None)

    def attach(self, lease_id: str, job_id: str, owner: str, ttl_ms: int, heartbeat_interval_ms: int) -> LeaseInfo:
        existing = self._leases_by_job.get(job_id)
        now = self._now_fn()
        if existing and not existing.expired(now):
            raise ValueError("lease_already_attached")
        lease = LeaseInfo(
            lease_id=lease_id,
            job_id=job_id,
            client_id=owner,
            ttl_ms=ttl_ms,
            last_heartbeat_ts=now,
            lease_expiry_ts=now + timedelta(milliseconds=ttl_ms),
            heartbeat_interval_ms=heartbeat_interval_ms,
            state="ATTACHED",
        )
        self._leases_by_id[lease_id] = lease
        self._leases_by_job[job_id] = lease
        return lease

    def heartbeat(self, lease_id: str) -> bool:
        lease = self._leases_by_id.get(lease_id)
        if not lease:
            return False
        now = self._now_fn()
        if lease.expired(now):
            lease.state = "EXPIRED"
            return False
        lease.extend(lease.ttl_ms, now=now)
        return True

    def detach(self, lease_id: str) -> bool:
        lease = self._leases_by_id.get(lease_id)
        if not lease:
            return False
        lease.state = "DETACHED"
        self._leases_by_id.pop(lease_id, None)
        if self._leases_by_job.get(lease.job_id) == lease:
            self._leases_by_job.pop(lease.job_id, None)
        return True

    def reattach(self, lease_id: str, job_id: str, owner: str, ttl_ms: int, heartbeat_interval_ms: int) -> LeaseInfo:
        self.detach(lease_id)
        return self.attach(lease_id, job_id, owner, ttl_ms, heartbeat_interval_ms)

    def check_expired(self, lease_id: str) -> bool:
        lease = self._leases_by_id.get(lease_id)
        if not lease:
            return False
        if lease.expired(self._now_fn()):
            lease.state = "EXPIRED"
            self._leases_by_id.pop(lease_id, None)
            if self._leases_by_job.get(lease.job_id) == lease:
                self._leases_by_job.pop(lease.job_id, None)
            return True
        return False

    def invalidate_job(self, job_id: str) -> None:
        lease = self._leases_by_job.pop(job_id, None)
        if lease:
            lease.state = "EXPIRED"
            self._leases_by_id.pop(lease.lease_id, None)
