from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Dict, Optional

from .executor import StepExecutor
from .jobmanager import JobManager
from .lease import LeaseManager
from .logging_store import LoggingStore
from .protocol import (
    AttachAck,
    HeartbeatAck,
    LogsResponse,
    ProgressResponse,
    ReattachAck,
)
from .resource_lock import ResourceLockManager
from .telemetry import TelemetryStore


@dataclass
class DaemonState:
    lease_id: Optional[str] = None
    client_id: Optional[str] = None
    heartbeat_interval_ms: int = 0


class DaemonCore:
    def __init__(
        self,
        job_manager: JobManager,
        lease_manager: LeaseManager,
        resource_lock: ResourceLockManager,
        telemetry: TelemetryStore,
        logger: LoggingStore,
        executor: StepExecutor,
    ) -> None:
        self.job_manager = job_manager
        self.lease_manager = lease_manager
        self.resource_lock = resource_lock
        self.telemetry = telemetry
        self.logger = logger
        self.executor = executor
        self.state = DaemonState()

    def _lease_expiry(self, ttl_ms: int) -> str:
        return (datetime.utcnow() + timedelta(milliseconds=ttl_ms)).isoformat()

    def handle_attach(self, client_id: str, ttl_ms: int, heartbeat_interval_ms: int) -> Dict[str, Any]:
        lease_id = f"lease_{client_id}_{int(datetime.utcnow().timestamp())}"
        self.lease_manager.attach(lease_id, client_id, ttl_ms, heartbeat_interval_ms)
        self.state.lease_id = lease_id
        self.state.client_id = client_id
        self.state.heartbeat_interval_ms = heartbeat_interval_ms
        lease_info = {
            "lease_id": lease_id,
            "client_id": client_id,
            "lease_expiry_ts": self._lease_expiry(ttl_ms),
            "heartbeat_interval_ms": heartbeat_interval_ms,
        }
        self.job_manager.update_lease(lease_info)
        return AttachAck(
            lease_id=lease_id,
            lease_expiry_ts=lease_info["lease_expiry_ts"],
            heartbeat_interval_ms=heartbeat_interval_ms,
        ).to_dict()

    def handle_heartbeat(self, lease_id: str, ttl_ms: int) -> Dict[str, Any]:
        ok = self.lease_manager.heartbeat(lease_id, ttl_ms)
        if ok:
            self.job_manager.update_lease(
                {
                    "lease_id": lease_id,
                    "lease_expiry_ts": self._lease_expiry(ttl_ms),
                    "heartbeat_interval_ms": self.state.heartbeat_interval_ms,
                }
            )
        return HeartbeatAck(lease_id=lease_id, server_ts=datetime.utcnow().isoformat()).to_dict()

    def handle_detach(self, lease_id: str) -> bool:
        return self.lease_manager.detach(lease_id)

    def handle_progress(self) -> Dict[str, Any]:
        plan = self.job_manager.state.plan
        if not plan:
            return ProgressResponse(
                plan_id="",
                current_step_id=None,
                step_status={},
                budgets_used={},
                started_at="",
                updated_at="",
            ).to_dict()
        return ProgressResponse(
            plan_id=plan.plan_id,
            current_step_id=self.job_manager.state.current_step_id,
            step_status=self.job_manager.state.step_status,
            budgets_used=self.job_manager.state.budgets_used,
            started_at=self.job_manager.state.timestamps.get("started_at", ""),
            updated_at=self.job_manager.state.timestamps.get("updated_at", ""),
        ).to_dict()

    def handle_logs(self, cursor: Optional[str]) -> Dict[str, Any]:
        plan_id = self.job_manager.state.plan.plan_id if self.job_manager.state.plan else ""
        data = self.telemetry.get_logs_with_plan(plan_id, cursor)
        return LogsResponse(
            plan_id=plan_id,
            entries=data["entries"],
            next_cursor=data["next_cursor"],
        ).to_dict()

    def handle_reattach(self, lease_id: str, ttl_ms: int) -> Dict[str, Any]:
        self.lease_manager.heartbeat(lease_id, ttl_ms)
        plan_snapshot = {
            "plan_id": self.job_manager.state.plan.plan_id if self.job_manager.state.plan else "",
            "current_step_id": self.job_manager.state.current_step_id,
            "step_status": self.job_manager.state.step_status,
            "last_seq": self.job_manager.state.last_seq,
            "budgets_used": self.job_manager.state.budgets_used,
        }
        return ReattachAck(
            lease_id=lease_id,
            lease_expiry_ts=self._lease_expiry(ttl_ms),
            plan_snapshot=plan_snapshot,
        ).to_dict()
