from dataclasses import dataclass, field
from typing import Any, Dict, Optional, Tuple


@dataclass
class IdempotentTracker:
    last_seq: Dict[str, Dict[str, int]] = field(default_factory=dict)
    ack_cache: Dict[str, Dict[str, Dict[int, Dict[str, Any]]]] = field(default_factory=dict)

    def get_last_seq(self, plan_id: str, step_id: str) -> int:
        return self.last_seq.get(plan_id, {}).get(step_id, 0)

    def record_ack(self, plan_id: str, step_id: str, seq: int, ack: Dict[str, Any]) -> None:
        self.last_seq.setdefault(plan_id, {})[step_id] = seq
        self.ack_cache.setdefault(plan_id, {}).setdefault(step_id, {})[seq] = ack

    def cached_ack(self, plan_id: str, step_id: str, seq: int) -> Optional[Dict[str, Any]]:
        return self.ack_cache.get(plan_id, {}).get(step_id, {}).get(seq)

    def check_seq(self, plan_id: str, step_id: str, seq: int) -> Tuple[str, int]:
        last = self.get_last_seq(plan_id, step_id)
        if seq <= last:
            return "duplicate", last
        if seq != last + 1:
            return "gap", last
        return "ok", last

    def to_dict(self) -> Dict[str, Any]:
        return {"last_seq": self.last_seq, "ack_cache": self.ack_cache}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IdempotentTracker":
        return cls(
            last_seq=dict(data.get("last_seq", {})),
            ack_cache=dict(data.get("ack_cache", {})),
        )
