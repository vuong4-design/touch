from dataclasses import dataclass
from typing import Any, Dict, Optional

from .guard import GuardEvaluator
from .idempotent import IdempotentTracker
from .jobmanager import JobManager
from .telemetry import TelemetryStore


@dataclass
class StepResult:
    ok: bool
    data: Dict[str, Any]
    reason: str = ""

    def to_ack(self, plan_id: str, step_id: str, seq: int, status: str) -> Dict[str, Any]:
        return {
            "type": "STEP_ACK",
            "plan_id": plan_id,
            "step_id": step_id,
            "seq": seq,
            "status": status,
            "result": {"ok": self.ok, "data": self.data, "reason": self.reason},
        }


class StepExecutor:
    def __init__(self, job_manager: JobManager, tracker: IdempotentTracker, telemetry: TelemetryStore) -> None:
        self.job_manager = job_manager
        self.tracker = tracker
        self.telemetry = telemetry
        self.guard_evaluator = GuardEvaluator()

    def handle_step(self, msg: Dict[str, Any]) -> Dict[str, Any]:
        plan_id = msg.get("plan_id", "")
        step_id = msg.get("step_id", "")
        seq = int(msg.get("seq", 0))
        status, last_seq = self.tracker.check_seq(plan_id, step_id, seq)
        if status == "duplicate":
            cached = self.tracker.cached_ack(plan_id, step_id, seq)
            if cached:
                return cached
            return StepResult(ok=True, data={}, reason="duplicate").to_ack(plan_id, step_id, seq, "duplicate")
        if status == "gap":
            return StepResult(ok=False, data={}, reason=f"seq_gap(last={last_seq})").to_ack(
                plan_id, step_id, seq, "rejected"
            )
        guards = tuple(msg.get("guards", []))
        guard_result = self.guard_evaluator.evaluate_step(guards)
        if not guard_result.ok:
            result = StepResult(ok=False, data={}, reason=guard_result.reason)
            ack = result.to_ack(plan_id, step_id, seq, "rejected")
            self.tracker.record_ack(plan_id, step_id, seq, ack)
            self.job_manager.record_step_status(step_id, "guard_failed")
            return ack
        result = StepResult(ok=True, data={})
        ack = result.to_ack(plan_id, step_id, seq, "accepted")
        self.tracker.record_ack(plan_id, step_id, seq, ack)
        self.job_manager.update_last_seq(plan_id, step_id, seq)
        self.job_manager.record_step_status(step_id, "accepted")
        return ack
