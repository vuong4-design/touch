import time
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Optional

from .jobmanager import JobManager
from .logging_store import FileLogger, LoggingStore
from .plan import Plan
from .telemetry import TelemetryStore
from .watchdog import BudgetLimits, BudgetUsage, Watchdog


@dataclass
class RunnerState:
    current_step_id: Optional[str] = None
    running: bool = False
    budget_usage: BudgetUsage = BudgetUsage()
    last_progress_ts: Optional[float] = None


class PlanRunner:
    def __init__(
        self,
        job_manager: JobManager,
        telemetry: TelemetryStore,
        logger: LoggingStore,
        watchdog: Watchdog,
        resource_lock: Optional[Any] = None,
        recorder: Optional[list] = None,
    ) -> None:
        self.job_manager = job_manager
        self.telemetry = telemetry
        self.logger = logger
        self.watchdog = watchdog
        self.resource_lock = resource_lock
        self.recorder = recorder
        self.state = RunnerState()

    def load_plan(self, plan: Plan) -> None:
        plan.validate()
        self.job_manager.restore_plan(plan)
        self.state.current_step_id = plan.steps[0].step_id if plan.steps else None

    def run(self, job_id: str, file_logger: Optional[FileLogger] = None, progress_timeout_ms: int = 0) -> None:
        plan = self.job_manager.state.plan
        if not plan:
            return
        if self.state.last_progress_ts is None:
            self.state.last_progress_ts = time.time()
        self.state.running = True
        start_idx = 0
        job = self.job_manager.status(job_id)
        if job:
            start_idx = int(job.get("current_step_index", 0))
        try:
            for idx in range(start_idx, len(plan.steps)):
                step = plan.steps[idx]
                self.state.current_step_id = step.step_id
                ok, reason = self.watchdog.check_plan_budget(self.state.budget_usage)
                if not ok:
                    record = self.logger.log("warn", "plan_budget_exceeded", {"reason": reason})
                    if file_logger:
                        file_logger.log(job_id, record)
                    self.job_manager.stop(job_id, "HUNG")
                    self.state.running = False
                    return
                if progress_timeout_ms and self.watchdog.check_progress_timeout(
                    datetime.fromtimestamp(self.state.last_progress_ts), progress_timeout_ms
                ):
                    record = self.logger.log("error", "progress_timeout", {"timeout_ms": progress_timeout_ms})
                    if file_logger:
                        file_logger.log(job_id, record)
                    self.job_manager.stop(job_id, "HUNG")
                    self.state.running = False
                    if self.resource_lock:
                        self.resource_lock.release_all(job_id)
                    return
                record = self.logger.log("info", "start_step", {"step_id": step.step_id})
                if file_logger:
                    file_logger.log(job_id, record)
                success = self._execute_step(step)
                if not success:
                    self.job_manager.stop(job_id, "FAILED")
                    record = self.logger.log("error", "end_step", {"step_id": step.step_id, "status": "failed"})
                    if file_logger:
                        file_logger.log(job_id, record)
                    self.state.running = False
                    if self.resource_lock:
                        self.resource_lock.release_all(job_id)
                    return
                self.state.last_progress_ts = time.time()
                self.job_manager.update_checkpoint(job_id, idx + 1)
                record = self.logger.log("info", "end_step", {"step_id": step.step_id, "status": "ok"})
                if file_logger:
                    file_logger.log(job_id, record)
            self.job_manager.record_step_status(self.state.current_step_id or "", "finished")
            self.job_manager.stop(job_id, "FINISHED")
            record = self.logger.log("info", "job_finished", {"job_id": job_id})
            if file_logger:
                file_logger.log(job_id, record)
            self.state.running = False
        finally:
            if not self.state.running and self.resource_lock:
                self.resource_lock.release_all(job_id)

    @staticmethod
    def build_watchdog(plan: Plan) -> Watchdog:
        limits = BudgetLimits(
            time_ms=plan.budgets.time_ms,
            touch_ops=plan.budgets.touch_ops,
            retry_total=plan.budgets.retry_total,
        )
        return Watchdog(limits)

    @staticmethod
    def build_usage() -> BudgetUsage:
        return BudgetUsage()

    def _execute_step(self, step: Any) -> bool:
        retry_max = step.retry.max if step.retry else 0
        backoff = step.retry.backoff_ms if step.retry else 0
        for attempt in range(retry_max + 1):
            if step.type == "sleep":
                time.sleep(step.payload.get("ms", 0) / 1000.0)
                return True
            if step.type == "touch":
                return True
            if step.type == "record":
                if self.recorder is not None:
                    self.recorder.append(step.payload.get("value"))
                return True
            if attempt < retry_max:
                time.sleep(backoff / 1000.0)
        return False
