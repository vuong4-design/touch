from dataclasses import dataclass
from typing import Optional

from .jobmanager import JobManager
from .logging_store import LoggingStore
from .plan import Plan
from .telemetry import TelemetryStore
from .watchdog import BudgetLimits, BudgetUsage, Watchdog


@dataclass
class RunnerState:
    current_step_id: Optional[str] = None
    running: bool = False


class PlanRunner:
    def __init__(
        self,
        job_manager: JobManager,
        telemetry: TelemetryStore,
        logger: LoggingStore,
        watchdog: Watchdog,
    ) -> None:
        self.job_manager = job_manager
        self.telemetry = telemetry
        self.logger = logger
        self.watchdog = watchdog
        self.state = RunnerState()

    def load_plan(self, plan: Plan) -> None:
        plan.validate()
        self.job_manager.restore_plan(plan)
        self.state.current_step_id = plan.steps[0].step_id if plan.steps else None

    def tick(self) -> None:
        if not self.job_manager.state.plan or not self.state.current_step_id:
            return
        self.state.running = True
        self.logger.log("info", "runner_tick", {"step_id": self.state.current_step_id})

    @staticmethod
    def build_watchdog(plan: Plan) -> Watchdog:
        limits = BudgetLimits(
            time_ms=plan.budgets.time_ms,
            touch_ops=plan.budgets.touch_ops,
            retry_total=plan.budgets.retry_total,
        )
        return Watchdog(limits)

    @staticmethod
    def build_usage() -> BudgetUsage:
        return BudgetUsage()
