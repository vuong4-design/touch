from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Dict, Optional


@dataclass
class ResourceLock:
    owner_id: str
    resource: str
    mode: str
    expires_at: datetime

    def expired(self, now: Optional[datetime] = None) -> bool:
        now = now or datetime.utcnow()
        return now >= self.expires_at


class ResourceLockManager:
    def __init__(self) -> None:
        self._locks: Dict[str, ResourceLock] = {}

    def acquire(self, owner_id: str, resource: str, mode: str, timeout_ms: int) -> bool:
        now = datetime.utcnow()
        existing = self._locks.get(resource)
        if existing and not existing.expired(now):
            return False
        self._locks[resource] = ResourceLock(
            owner_id=owner_id,
            resource=resource,
            mode=mode,
            expires_at=now + timedelta(milliseconds=timeout_ms),
        )
        return True

    def release(self, owner_id: str, resource: str) -> bool:
        lock = self._locks.get(resource)
        if not lock or lock.owner_id != owner_id:
            return False
        self._locks.pop(resource, None)
        return True

    def release_all(self, owner_id: str) -> int:
        released = 0
        for resource, lock in list(self._locks.items()):
            if lock.owner_id == owner_id:
                self._locks.pop(resource, None)
                released += 1
        return released

    def check_owner(self, owner_id: str, resource: str) -> bool:
        lock = self._locks.get(resource)
        if not lock:
            return False
        if lock.expired():
            self._locks.pop(resource, None)
            return False
        return lock.owner_id == owner_id
