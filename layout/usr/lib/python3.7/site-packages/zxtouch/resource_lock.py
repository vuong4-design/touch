from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Dict, Optional, Set


@dataclass
class ResourceLock:
    resource: str
    mode: str
    expires_at: datetime
    owners: Set[str] = field(default_factory=set)

    def expired(self, now: Optional[datetime] = None) -> bool:
        now = now or datetime.utcnow()
        return now >= self.expires_at


class ResourceLockManager:
    def __init__(self) -> None:
        self._locks: Dict[str, ResourceLock] = {}

    def acquire(self, owner_id: str, resource: str, mode: str, timeout_ms: int) -> bool:
        now = datetime.utcnow()
        existing = self._locks.get(resource)
        if existing and not existing.expired(now):
            if existing.mode == "read" and mode == "read":
                existing.owners.add(owner_id)
                return True
            return False
        self._locks[resource] = ResourceLock(
            resource=resource,
            mode=mode,
            expires_at=now + timedelta(milliseconds=timeout_ms),
            owners={owner_id},
        )
        return True

    def release(self, owner_id: str, resource: str) -> bool:
        lock = self._locks.get(resource)
        if not lock or owner_id not in lock.owners:
            return False
        lock.owners.discard(owner_id)
        if not lock.owners:
            self._locks.pop(resource, None)
        return True

    def release_all(self, owner_id: str) -> int:
        released = 0
        for resource, lock in list(self._locks.items()):
            if owner_id in lock.owners:
                lock.owners.discard(owner_id)
                if not lock.owners:
                    self._locks.pop(resource, None)
                released += 1
        return released

    def check_owner(self, owner_id: str, resource: str) -> bool:
        lock = self._locks.get(resource)
        if not lock:
            return False
        if lock.expired():
            self._locks.pop(resource, None)
            return False
        return owner_id in lock.owners
