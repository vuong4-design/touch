from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Dict, Optional, Tuple


@dataclass
class GuardResult:
    ok: bool
    reason: str = ""


class GuardEvaluator:
    def evaluate(self, guard_type: str, params: Dict[str, Any], context: Optional[Dict[str, Any]] = None) -> GuardResult:
        context = context or {}
        if guard_type == "always":
            return GuardResult(ok=True)
        if guard_type == "never":
            return GuardResult(ok=False, reason="guard_never")
        if guard_type == "timeout_ms":
            started_at = context.get("started_at")
            if not started_at:
                return GuardResult(ok=False, reason="missing_started_at")
            timeout_ms = int(params.get("timeout_ms", 0))
            if datetime.utcnow() - started_at > timedelta(milliseconds=timeout_ms):
                return GuardResult(ok=False, reason="guard_timeout")
            return GuardResult(ok=True)
        if guard_type == "app_foreground":
            return GuardResult(
                ok=context.get("frontmost_app_id") == params.get("bundle_id"),
                reason="app_not_foreground",
            )
        if guard_type == "pixel_match":
            expected = params.get("rgb")
            return GuardResult(
                ok=context.get("pixel") == expected,
                reason="pixel_mismatch",
            )
        return GuardResult(ok=False, reason=f"unsupported_guard:{guard_type}")

    def evaluate_step(self, guards: Tuple[Dict[str, Any], ...], context: Optional[Dict[str, Any]] = None) -> GuardResult:
        for guard in guards:
            result = self.evaluate(guard.get("type", ""), guard.get("params", {}), context)
            if not result.ok:
                return result
        return GuardResult(ok=True)
