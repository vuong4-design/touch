from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional


@dataclass
class LogRecord:
    level: str
    message: str
    timestamp: str = field(default_factory=lambda: datetime.utcnow().isoformat())
    context: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "level": self.level,
            "message": self.message,
            "timestamp": self.timestamp,
            "context": self.context,
        }


class LoggingStore:
    def __init__(self, max_entries: int = 1000) -> None:
        self._max_entries = max_entries
        self._entries: List[LogRecord] = []

    def append(self, record: LogRecord) -> None:
        self._entries.append(record)
        if len(self._entries) > self._max_entries:
            self._entries = self._entries[-self._max_entries :]

    def log(self, level: str, message: str, context: Optional[Dict[str, Any]] = None) -> LogRecord:
        record = LogRecord(level=level, message=message, context=context or {})
        self.append(record)
        return record

    def list(self) -> List[Dict[str, Any]]:
        return [entry.to_dict() for entry in self._entries]


class FileLogger:
    def __init__(self, base_dir: str, max_bytes: int = 1024 * 256) -> None:
        self.base_dir = Path(base_dir)
        self.max_bytes = max_bytes
        self.base_dir.mkdir(parents=True, exist_ok=True)

    def _log_path(self, job_id: str) -> Path:
        return self.base_dir / f"{job_id}.log"

    def get_path(self, job_id: str) -> Path:
        return self._log_path(job_id)

    def _rotate(self, path: Path) -> None:
        if not path.exists():
            return
        if path.stat().st_size <= self.max_bytes:
            return
        backup = path.with_suffix(".log.1")
        if backup.exists():
            backup.unlink()
        path.rename(backup)

    def log(self, job_id: str, record: LogRecord) -> None:
        path = self._log_path(job_id)
        self._rotate(path)
        line = f"{record.timestamp} {record.level} {record.message} {record.context}\\n"
        with path.open("a", encoding="utf-8") as handle:
            handle.write(line)
