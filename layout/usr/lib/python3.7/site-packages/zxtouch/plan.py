from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional


@dataclass
class RetryPolicy:
    max: int = 0
    backoff_ms: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return {"max": self.max, "backoff_ms": self.backoff_ms}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RetryPolicy":
        return cls(max=int(data.get("max", 0)), backoff_ms=int(data.get("backoff_ms", 0)))

@dataclass
class OnFail:
    action: str = "abort"
    target: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        data = {"action": self.action}
        if self.target is not None:
            data["target"] = self.target
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "OnFail":
        return cls(action=str(data.get("action", "abort")), target=data.get("target"))

@dataclass
class StepBudget:
    time_ms: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return {"time_ms": self.time_ms}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "StepBudget":
        return cls(time_ms=int(data.get("time_ms", 0)))

@dataclass
class PlanBudget:
    time_ms: int = 0
    touch_ops: int = 0
    retry_total: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return {
            "time_ms": self.time_ms,
            "touch_ops": self.touch_ops,
            "retry_total": self.retry_total,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "PlanBudget":
        return cls(
            time_ms=int(data.get("time_ms", 0)),
            touch_ops=int(data.get("touch_ops", 0)),
            retry_total=int(data.get("retry_total", 0)),
        )

@dataclass
class Guard:
    type: str
    params: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {"type": self.type, "params": self.params}

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Guard":
        return cls(type=str(data.get("type", "")), params=dict(data.get("params", {})))

@dataclass
class Step:
    step_id: str
    type: str
    payload: Dict[str, Any] = field(default_factory=dict)
    guards: List[Guard] = field(default_factory=list)
    retry: RetryPolicy = field(default_factory=RetryPolicy)
    on_fail: OnFail = field(default_factory=OnFail)
    budget: StepBudget = field(default_factory=StepBudget)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "step_id": self.step_id,
            "type": self.type,
            "payload": self.payload,
            "guards": [guard.to_dict() for guard in self.guards],
            "retry": self.retry.to_dict(),
            "on_fail": self.on_fail.to_dict(),
            "budget": self.budget.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Step":
        return cls(
            step_id=str(data.get("step_id", "")),
            type=str(data.get("type", "")),
            payload=dict(data.get("payload", {})),
            guards=[Guard.from_dict(item) for item in data.get("guards", [])],
            retry=RetryPolicy.from_dict(data.get("retry", {})),
            on_fail=OnFail.from_dict(data.get("on_fail", {})),
            budget=StepBudget.from_dict(data.get("budget", {})),
        )

@dataclass
class Plan:
    plan_id: str
    plan_version: int = 1
    created_at: str = ""
    budgets: PlanBudget = field(default_factory=PlanBudget)
    steps: List[Step] = field(default_factory=list)
    on_fail: OnFail = field(default_factory=OnFail)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "plan_id": self.plan_id,
            "plan_version": self.plan_version,
            "created_at": self.created_at,
            "budgets": self.budgets.to_dict(),
            "steps": [step.to_dict() for step in self.steps],
            "on_fail": self.on_fail.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Plan":
        return cls(
            plan_id=str(data.get("plan_id", "")),
            plan_version=int(data.get("plan_version", 1)),
            created_at=str(data.get("created_at", "")),
            budgets=PlanBudget.from_dict(data.get("budgets", {})),
            steps=[Step.from_dict(item) for item in data.get("steps", [])],
            on_fail=OnFail.from_dict(data.get("on_fail", {})),
        )

    def validate(self) -> None:
        if not self.plan_id:
            raise ValueError("plan_id is required")
        step_ids = {step.step_id for step in self.steps}
        if len(step_ids) != len(self.steps):
            raise ValueError("step_id must be unique within a plan")
        for step in self.steps:
            if not step.step_id:
                raise ValueError("step_id is required for every step")
            if not step.type:
                raise ValueError("step.type is required for every step")
