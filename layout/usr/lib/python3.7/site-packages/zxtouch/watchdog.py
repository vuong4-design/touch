from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Optional, Tuple


@dataclass
class BudgetLimits:
    time_ms: int = 0
    touch_ops: int = 0
    retry_total: int = 0


@dataclass
class BudgetUsage:
    time_ms: int = 0
    touch_ops: int = 0
    retry_total: int = 0


class Watchdog:
    def __init__(self, plan_limits: BudgetLimits) -> None:
        self.plan_limits = plan_limits
        self.plan_start = datetime.utcnow()

    def step_deadline(self, step_time_ms: int) -> datetime:
        return datetime.utcnow() + timedelta(milliseconds=step_time_ms)

    def check_step_timeout(self, step_deadline: datetime, now: Optional[datetime] = None) -> bool:
        now = now or datetime.utcnow()
        return now >= step_deadline

    def check_plan_budget(self, usage: BudgetUsage, now: Optional[datetime] = None) -> Tuple[bool, str]:
        now = now or datetime.utcnow()
        if self.plan_limits.time_ms and now - self.plan_start > timedelta(milliseconds=self.plan_limits.time_ms):
            return False, "plan_timeout"
        if self.plan_limits.touch_ops and usage.touch_ops > self.plan_limits.touch_ops:
            return False, "touch_budget_exceeded"
        if self.plan_limits.retry_total and usage.retry_total > self.plan_limits.retry_total:
            return False, "retry_budget_exceeded"
        return True, ""
